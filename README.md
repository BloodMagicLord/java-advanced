# Java-advanced

Homeworks from Java-advanced course, ITMO 2021-2022

## [Обход файлов](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/walk/Walk.java)
1. Разработайте класс Walk, осуществляющий подсчет хеш-сумм файлов.
	- Формат запуска:
	```
	java Walk <входной файл> <выходной файл>
	```
	- Входной файл содержит список файлов, которые требуется обойти.
	- Выходной файл должен содержать по одной строке для каждого файла. Формат строки:
	```
	<шестнадцатеричная хеш-сумма> <путь к файлу>
	```
    - Для подсчета хеш-суммы используйте алгоритм [SHA-1](https://en.wikipedia.org/wiki/SHA-1) (поддержка есть в стандартной библиотеке).
    - Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы 40 нулей.
	- Кодировка входного и выходного файлов — UTF-8.
	- Если родительская директория выходного файла не существует, то соответствующий путь надо создать.
	- Размеры файлов могут превышать размер оперативной памяти.
	- Пример: 
  <table>
      <tbody>
        <tr>
          <th>Входной файл:</th>
        </tr>
        <tr>
          <td>
            <ul>
              <li>samples/1</li>
              <li>samples/12</li>
              <li>samples/123</li>
              <li>samples/1234</li>
              <li>samples/1 </li>
              <li>samples/binary </li>
              <li>samples/no-such-file </li>
            </ul>
         </td>
        </tr>
      </tbody>
    </table> <table>
      <tbody>
        <tr>
          <th>Выходной файл:</th>
        </tr>
        <tr>
          <td>
            <ul>
              <li>356a192b7913b04c54574d18c28d46e6395428ab samples/1   </li>
              <li>7b52009b64fd0a2a49e6d8a939753077792b0554 samples/12 </li>
              <li>40bd001563085fc35165329ea1ff5c5ecbdbbeef samples/123 </li>
              <li>7110eda4d09e062aa5e4a390b0a572ac0d2c0220 samples/1234 </li>
              <li>356a192b7913b04c54574d18c28d46e6395428ab samples/1  </li>
              <li>4916d6bdb7f78e6803698cab32d1586ea457dfc8 samples/binary</li>
              <li>0000000000000000000000000000000000000000 samples/no-such-file</li>
            </ul>
         </td>
        </tr>
      </tbody>
    </table> 
    
2. Сложный вариант:
	- Разработайте класс RecursiveWalk, осуществляющий подсчет хеш-сумм файлов в директориях.
	- Входной файл содержит список файлов и директорий, которые требуется обойти. Обход директорий осуществляется рекурсивно.
	- Пример: 
  <table>
      <tbody>
        <tr>
          <th>Входной файл:</th>
        </tr>
        <tr>
          <td>
            <ul>
              <li>samples/binary</li>
              <li>samples</li>
              <li>samples/no-such-file</li>
            </ul>
         </td>
        </tr>
      </tbody>
    </table> <table>
      <tbody>
        <tr>
          <th>Выходной файл:</th>
        </tr>
        <tr>
          <td>
            <ul>
              <li>4916d6bdb7f78e6803698cab32d1586ea457dfc8 samples/binary</li>
              <li>356a192b7913b04c54574d18c28d46e6395428ab samples/1</li>
              <li>7b52009b64fd0a2a49e6d8a939753077792b0554 samples/12</li>
              <li>40bd001563085fc35165329ea1ff5c5ecbdbbeef samples/123</li>
              <li>7110eda4d09e062aa5e4a390b0a572ac0d2c0220 samples/1234</li>
              <li>4916d6bdb7f78e6803698cab32d1586ea457dfc8 samples/binary</li>
              <li>0000000000000000000000000000000000000000 samples/no-such-file</li>
            </ul>
         </td>
        </tr>
      </tbody>
    </table>   
                        
3. При выполнении задания следует обратить внимание на:
	- Дизайн и обработку исключений, диагностику ошибок.
	- Программа должна корректно завершаться даже в случае ошибки.
	- Корректная работа с вводом-выводом.
	- Отсутствие утечки ресурсов.
	
4. Требования к оформлению задания:
	- Проверяется исходный код задания.
	- Весь код должен находиться в пакете info.kgeorgiy.ja.фамилия.walk.

## [Множество на массиве](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/arrayset/ArraySet.java)

1. Разработайте класс ArraySet, реализующий неизменяемое упорядоченное множество.
	- Класс `ArraySet` должен реализовывать интерфейс [SortedSet](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/SortedSet.html).
	- Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
2. При выполнении задания следует обратить внимание на:
	- Применение стандартных коллекций.
	- Избавление от повторяющегося кода.
	
## [Студенты](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/student/StudentDB.java)
1.	Разработайте класс `StudentDB`, осуществляющий поиск по базе данных студентов.
	- Класс `StudentDB` должен реализовывать интерфейс `StudentQuery`.
	- Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
2. При выполнении задания следует обратить внимание на:
	- Применение лямбда-выражений и потоков.
	- Избавление от повторяющегося кода.
	
## [Implementor](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/implementor/Implementor.java)
1. Реализуйте класс `Implementor`, генерирующий реализации классов и интерфейсов.
	- Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
	- В результате работы должен быть сгенерирован java-код класса с суффиксом Impl, расширяющий (реализующий) указанный класс (интерфейс).
	- Сгенерированный класс должен компилироваться без ошибок.
	- Сгенерированный класс не должен быть абстрактным.
	- Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.

## [Jar и Javadoc](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/implementor/Implementor.java)
1. Jar
	- Модифицируйте `Implementor` так, чтобы при запуске с аргументами -jar `имя-класса файл.jar` он генерировал .jar-файл с реализацией соответствующего класса (интерфейса). Для компиляции используйте код из тестов.
	- Создайте .jar-файл, содержащий скомпилированный Implementor и сопутствующие классы.
		- Созданный .jar-файл должен запускаться командой java -jar.
		- Запускаемый .jar-файл должен принимать те же аргументы командной строки, что и класс Implementor.
	- Для проверки, кроме исходного кода, также должны быть представлены:
		- Cкрипт для создания запускаемого .jar-файла, в том числе, исходный код манифеста.
		- Pапускаемый .jar-файл.
2. Javadoc
	- Документируйте класс Implementor и сопутствующие классы с применением Javadoc.
		- Должны быть документированы все классы и все члены классов, в том числе private.
		- Документация должна генерироваться без предупреждений.
		- Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
	- Для проверки, кроме исходного кода, также должны быть представлены:
		- Cкрипт для генерации документации (он может рассчитывать, что рядом с вашим репозиторием склонирован репозиторий курса).
		- Cгенерированная документация.
3. Это домашнее задание связано с предыдущим. Предыдущее домашнее задание отдельно сдать будет нельзя.
4. В последующих домашних заданиях все public и protected сущности должны быть документированы.

## [Итеративный параллелизм](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/concurrent/IterativeParallelism.java)
1. Реализуйте класс `IterativeParallelism`, который будет обрабатывать списки в несколько потоков.
2. Должны быть реализованы следующие методы:
    - `minimum(threads, list, comparator)` — первый минимум;
    - `maximum(threads, list, comparator)` — первый максимум;
    - `all(threads, list, predicate)` — проверка, что все элементы списка, удовлетворяют предикату;
    - `any(threads, list, predicate)` — проверка, что существует элемент списка, удовлетворяющий предикату.
3. Во все функции передается параметр `threads` — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков относительно мало.
4. Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
5. При выполнении задания **нельзя** использовать *Concurrency Utilities*.
6. Рекомендуется подумать, какое отношение к заданию имеют [моноиды](https://en.wikipedia.org/wiki/Monoid).


## [Параллельный запуск](https://github.com/BloodMagicLord/java-advanced/blob/main/java-solutions/info/kgeorgiy/ja/Maksonov/concurrent/ParallelMapperImpl.java)
1. Напишите класс `ParallelMapperImpl`, реализующий интерфейс `ParallelMapper`.
    ```Java
    public interface ParallelMapper extends AutoCloseable {
        <T, R> List<R> map(
            Function<? super T, ? extends R> f,
            List<? extends T> args
        ) throws InterruptedException;
    
        @Override
        void close();
    }
    ```
    - Метод `run` должен параллельно вычислять функцию f на каждом из указанных аргументов (args).
    - Метод `close` должен останавливать все рабочие потоки.
    - Конструктор `ParallelMapperImpl(int threads)` создает `threads` рабочих потоков, которые могут быть использованы для распараллеливания.
    - К одному `ParallelMapperImpl` могут одновременно обращаться несколько клиентов.
    - Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
    - В реализации не должно быть активных ожиданий.
2. Доработайте класс `IterativeParallelism` так, чтобы он мог использовать `ParallelMapper`.
    - Добавьте конструктор `IterativeParallelism(ParallelMapper)`
    - Методы класса должны делить работу на `threads` фрагментов и исполнять их при помощи `ParallelMapper`.
    - При наличии `ParallelMapper` сам `IterativeParallelism` новые потоки создавать не должен.
    - Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один `ParallelMapper`.


## [HelloUDP](https://github.com/BloodMagicLord/java-advanced/tree/main/java-solutions/info/kgeorgiy/ja/Maksonov/hello)
1. Реализуйте клиент и сервер, взаимодействующие по UDP.
2. Класс `HelloUDPClient` должен отправлять запросы на сервер, принимать результаты и выводить их на консоль.
    - Аргументы командной строки:
        1. Имя или ip-адрес компьютера, на котором запущен сервер.
        2. Номер порта, на который отсылать запросы.
        3. Префикс запросов (строка).
        4. Число параллельных потоков запросов.
        5. Число запросов в каждом потоке.
    - Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заново.
    - Запросы должны формироваться по схеме `<префикс запросов><номер потока>_<номер запроса в потоке>`.
3. Класс `HelloUDPServer` должен принимать задания, отсылаемые классом `HelloUDPClient` и отвечать на них.
    - Аргументы командной строки:
        1. Номер порта, по которому будут приниматься запросы.
        2. Число рабочих потоков, которые будут обрабатывать запросы.
    - Ответом на запрос должно быть `Hello, <текст запроса>`.
    - Несмотря на то, что текущий способ получения ответа по запросу очень прост, сервер должен быть рассчитан на ситуацию, когда этот процесс может требовать много ресурсов и времени.
    - Если сервер не успевает обрабатывать запросы, прием запросов может быть временно приостановлен.

## [HelloNonblockingUDP](https://github.com/BloodMagicLord/java-advanced/tree/main/java-solutions/info/kgeorgiy/ja/Maksonov/hello)
1. Реализуйте клиент и сервер, взаимодействующие по UDP, используя только неблокирующий ввод-вывод.
2. Класс `HelloUDPNonblockingClient` должен иметь функциональность аналогичную `HelloUDPClient`, но без создания новых потоков.
3. Класс `HelloUDPNonblockingServer` должен иметь функциональность аналогичную `HelloUDPServer`, но все операции с сокетом должны производиться в одном потоке.
4. В реализации не должно быть активных ожиданий, в том числе через `Selector`.
5. Обратите внимание на выделение общего кода старой и новой реализации.
